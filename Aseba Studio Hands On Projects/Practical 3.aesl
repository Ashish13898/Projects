<!DOCTYPE aesl-source>
<network>


<!--list of global events-->
<constant name="SPEED" value="500"/>
<constant name="STOP" value="0"/>
<constant name="THRESHOLD" value="850"/>
<constant name="TURNING" value="2"/>
<constant name="TURN_AMOUNT" value="500"/>
<constant name="WANDER" value="1"/>


<!--node -->
<node name=""><![CDATA[# Thymio Program 2: Wandering
# Thymio will wander, while keeping within the E300 Table Arena black line
# enclosed area.
# Ashish Dave, 16th November, 2020
# ***********************************************************************
# Constants:
# THRESHOLD = Line sensor light/dark threshold
# SPEED = Overall robot speed (range from 50 to 500)
# TURN_AMOUNT = When turning, time delay to switch back to wandering
# STOP = to stop the robot
# TURNING = when robot is turning
# TURN_AMOUNT = Amount of seconds to hold before calling timer0
# ***********************************************************************
# Robot states:
# WANDER = 1
# TURNING = 2
# STOP = 0 # Additional functionality, see Question 5.
# ***********************************************************************
# Variables

var state = STOP # Start off wandering
# Initialise program
var i = 0
var cmAfterTurn = 0
var myrand_n = 5  #input
var myrand_m  = 20  #input


onevent button.backward
   # If the robot is in any other state, set it to wandering
	state = WANDER
	# If the robot is over the line, move it forward else go backwards
	if prox.horizontal[5] > 0 and prox.horizontal[6] > 0 then
		motor.left.target = SPEED
		motor.right.target = SPEED
	else
	  	motor.left.target = -SPEED
		motor.right.target = -SPEED
	end
	call leds.top(32, 0, 0)
return

onevent button.forward
   state = WANDER
	motor.left.target = SPEED
	motor.right.target = SPEED
	call leds.top(0, 32, 0)
return
	
onevent button.center
	state = STOP
return

onevent prox
	if state == WANDER then 
		if i == 0 then
		 			callsub myrand
					cmAfterTurn = i 
		end			
					timer.period[0] = SPEED * 100 / cmAfterTurn
	end
return

# If timer0 is nonzero then this event will be called after that amount of ms 
onevent timer0
if state == WANDER then 
	state = TURNING
   motor.left.target = TURN_AMOUNT
	motor.right.target = 0
	timer.period[1] = 1000 
	call leds.top(32,0,21)
	end
return	

onevent timer1
if state == TURNING then 
	state = WANDER
   motor.left.target = SPEED
	motor.right.target = SPEED
	call leds.top(32,0,21)
	end
return	

sub myrand
call math.rand(i)
i = abs(i % (myrand_m+1 - myrand_n)) + myrand_n

]]></node>


</network>
